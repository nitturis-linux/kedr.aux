Возможные принципы реализации нескольких перехватов одной и той же функции.

Проблема:
Нагрузки, выполняющие различные задачи, но требующие перехвата одинаковых функций.
В текущей реализации KEDR такие нагрузки нельзя использовать одновременно, поэтому, чтобы решать одновременно несколько задач,
приходится вручную объединять заменяющие функции таких нагрузок. Что отрицательно сказывается на выполнении принципа независимости нагрузок.

Цель: 
Хотелось бы, чтобы объединение заменяющих функций выполнялось автоматически KEDR'ом.


1. Большинство нагрузок выполняют роль наблюдения за целевым модулем. При этом реализация их заменяющих функций выглядит примерно так:

<действия, выполняемые до вызова исходной функции>
<вызов исходной функции с неизмененными параметрами>
<действия, выполняемые после вызова исходной функции>

Действия, выполняемые в заменяющих функциях одной нагрузки почти никогда не зависят от действий, выполняемых в заменяющих
функциях другой. Поэтому логичным выглядит такой принцип объединения заменяющих функций:

<действия, выполняемые до вызова исходной функции(нагрузка 1)>
...
<действия, выполняемые до вызова исходной функции(нагрузка N)>
<вызов исходной функции с неизмененными параметрами>
<действия, выполняемые после вызова исходной функции(нагрузка N)>
...
<действия, выполняемые после вызова исходной функции(нагрузка 1)>

2. Есть два способа автоматизации такого объединения заменяющих функций:

1) Каждая нагрузка регистрирует свою заменяющую функцию, которая для вызова целевой функции
использует некоторую конструкцию, перехватываемую KEDR'ом.
Например,
    get_orig(original_function_address, payload)(args...),
где get_orig - функция KEDR'а, которая в зависимости от параметра payload возвращает либо адрес исходной функции, либо адрес заменяющей функции,
зарегистрированной другой нагрузкой.

При такой регистрации из заменяющих функций создается цепочка. Вместо вызова исходной функции вызывается первая функция этой цепочки, для которой
get_orig() возвращает следующую функцию из цепочки. Для последней функции цепочки get_orig() возвращает адрес исходной функции.

2) Каждая нагрузка регистрирует функцию, которая будет вызываться до вызова исходной функции, и/или функцию, которая будет вызываться после вызова
исходной функции.

Вместо вызова исходной функции вызывается функция-переходник, которая в своем коде сначала вызывается все pre-функции,
потом вызывает исходную функцию, затем вызывает все post-функции.

При этом, сигнатура pre-функций совпадает с сигнатурой исходной функции,
а post-функции в качестве дополнительного аргумента принимают результат исходной функции(если таковой есть).

Преимущество первого способа в том, что не требуется дополнительной функции-переходника,
код которой надо генерить для каждой перехватываемой функции. Также преимущество в том,
что pre- и post- функции могут при необходимости использовать общие локальные переменные.

Преимущество второго способа, что он точнее отражает специфику заменяющих функций, и все pre- и post-функции выполняются на одном уровне вложенности
(полезность этого будет видна далее).

3. Встречаются нагрузки, в которых заменяющая функция должна выполнить какой-то код ВМЕСТО вызова исходной функции.
Пример - fault simulation. Такого типа нагрузки могут быть несложно объедены с остальными, но при условии, что для каждой функции
существует не более одной заменяющей функции, которая выполняет код без вызова исходной функции.

4. Получение адреса вызова/возврата исходной функции в заменяющей.
В текущей реализации подмены функций и регистрации payload'ов адрес возврата из исходной функции доступен в заменяющей функции как
__builtin_return_address(0). Но такая простота получения адреса является следствием заранее известного механизма подмены вызовов функций
и единственности заменяющей функции для каждой исходной функции.
Однако при реализации любого способа автоматизации объединения заменяющих функций такой способ получения адреса возврата исходной функции в заменяющей
будет невалидным:
при способе (1) __builtin_return_address(0) для всех заменяющих функций, кроме первой в цепочке,
будет возвращен адрес их возврата в другие заменяющие функции.
при способе (2) __builtin_return_address(0) возвратит адрес возврата в функцию-переходник.

В обоих случаях можно использовать механизм save_stack_trace():
при способе (1) каждая заменяющая функция может узнать свой уровень вложенности(в момент вызова), и с учетом этого пропускать соответствующее
число кадров стека.
при способе (2) все pre- и post- функции имеют уровень вложенности 1.

Однако, применение механизма ядра save_stack_trace() имеет некоторые недостатки:
-этот механизм при некоторых конфигурациях ядра не работает (пусть даже такие конфигурации встречаются редко)
-в случае (1) должно обеспечиватся условие, что вызов следующей заменяющей функции цепочки происходит ровно из предыдущей,
без функций оберток (хотя это обычно выполняется).

Еще одна возможность обеспечить заменяющие функции информацией о адресе возврата из исходной функции - формировать такой адрес
в функции-переходнике и передавать его как дополнительный параметр заменяющим функциям.
При этом, в способе (2) реализация изменится не сильно, а в способе (1) придется использовать функцию-перехватчик, из-за чего
он теряет большУю часть своих плюсов по сравнению со способом (2).