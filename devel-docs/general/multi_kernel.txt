    Поддержка сборки пакета для установки, работающей с несколькими ядрами Linux.


                            Проблема

В задачах анализа модулей возникает ситуация, когда нужно проверять работу модулей ядра на нескольких версиях ядрах.

KEDR включает в себя модули ядра, которые должны собиратся отдельно для каждого ядра.
Поэтому для каждой версии ядра KEDR должен собираться заного, а для того, чтобы разные установки не конфликтовали по устанавливаемым файлам, эти установки должны выполнятся с разными префиксами.

С другой стороны, с модулями ядра в KEDR поставляются программы и скрипты, которые управляют этими модулями. И предполагается, что в большинстве случаев пользователь будет запускать именно эти программы и скрипты, а не загружать модули ядра напрямую. Эти программы и скрипты от версии ядра не зависят.

Но так как при сборке KEDR на новое ядро указывается новый префикс установки, то на новом ядре программы и скрипты будут устанавливаться в новое место, и способ их вызова становится зависящим от ядра.

Это неудобно.

Также наличие нескольких установок делает невозможным использование только глобальной установки, когда файлы устанавливаются по общепринятым путям.


                            Решение

Весь пакет KEDR делится на две части: common и per-kernel.

Per-kernel часть включает модули ядра и собирается и устанавливается отдельно для каждого ядра.

Сommon часть включает программы и скрипты KEDR, и собирается и устанавливается один раз для всех ядер.

При этом программы и скрипты написаны так, что они работают с модулями из установки per-kernel части, соответствующей ядру, загруженному в данный момент.

Такая раздельная сборка и установка далее называется "multi-kernel".


                        Реализация

[см. sources/cmake/modules/multi_kernel.cmake]


Иметь две отдельных части пакета KEDR под common и per-kernel части не очень удобно:
а) кросс-связи между компонентами из common и per-kernel становятся плохо отслеживаемыми
б) дублируется код, обрабатывающий общие параметры сборок common и per-kernel

Поэтому физически пакет KEDR один, но сборки "common" и "per-kernel"
в реальности выполняют разные участи cmake скриптов пакета:

1) участки скрипта, предназначенные только для common сборки, заключаются в блок
if(USER_PART)
...
endif(USER_PART)

2) участки скрипта, предназначенные только для per-kernel части, заключаются в блок
if(KERNEL_PART)
...
endif(KERNEL_PART)

3) участки скрипта, общие для common и per-kernel частей, никак не ограничиваются


                        Использование

1) Для сборки common части конфигурация выполняется так:
cmake -DUSER_PART_ONLY=on ....

Это преобразуется в 
USER_PART=on
KERNEL_PART=off

2) Для сборки per-kernel части конфигурация выполняется так:
cmake -DKERNEL_PART_ONLY=on ....

Это преобразуется в 
USER_PART=off
KERNEL_PART=on

Все остальные параметры конфигурации per-kernel части должны быть "совместимы" с параметрами конфигурации common части.
Т.е. параметры, влияющие на обе части, должны быть одинаковыми:
- префикс установки (CMAKE_INSTALL_PREFIX)
- наличие подсистем (KEDR_TRACE, KEDR_LEAK_CHECK)
- наличие payload'ов того или иного типа (KEDR_STANDARD_CALLM_PAYLOADS, KEDR_STANDARD_FSIM_PAYLOADS)
- настройки payload'ов (KEDR_ENABLE_CALLER_ADDRESS)

С другой стороны, флаги компиляции ядерного кода и пользовательского могут быть различными.

Тестирование(WITH_TESTING) достаточно включить в per-kernel части(см. далее).

3) Обычная (не multi-kernel) сборка выполняется без дополнительных параметров, что интерпритируется как

USER_PART=on
KERNEL_PART=on



                multi-kernel и соглашения по путям установки компонентов

В силу особенностей KEDR, multi-kernel сборка разрешена только для глобальной установки.

При этом все пути установки (предназначенные для использования извне) не зависят от того, была ли установка
multi-kernel или обычная.


                    multi-kernel и тестирование KEDR

Все тесты KEDR собираются и устанавливаются в per-kernel части.
Поэтому параметр WITH_TESTING достаточно включить только при сборке этой части.
При этом скрипт запуска тестирования находится в директории, зависящей от
ядра:
<var>/tests/`uname -r`/run_tests.sh

Если включить WITH_TESTING при сборке common части, то будет дополнительно
установлен скрипт
<var>/tests/run_tests.sh
который просто вызывает скрипт, установленный в per-kernel сборке.
