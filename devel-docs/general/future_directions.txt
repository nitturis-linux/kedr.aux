Направления развития KEDR после версии 0.2.

1. Возможность разным payload'ам перехватывать одинаковые функции.

Зачем:
Уже сейчас есть модули с нагрузкой, выполняющие различные задачи: call monitoring, fault simulation, leak check.
Часто есть потребность использовать все эти нагрузки одновременно, но множества перехватываемых функций пересекаются, поэтому
на данный момент одновременно их использовать нельзя.
Первые две нагрузки(call monitoring и fault simulation) были объеденены в один модуль,
но цена такого объединения - резкое ограничение возможностей вариации реализации и функциональности.
Так как пришлось создавать такой модуль генератором на основе data-файлов. Даже мелкое изменение реализации одной нагрузки требует
редактирования кода, относящегося к другой нагрузке. Изменение функциональности одной нагрузки возможно только безусловное -
старый вариант функциональности перестает поддерживатся. Пример такого изменения - переменная caller_address для fault simulation.
Реализация такой переменной в опциональном виде затронула большУю часть пакета с KEDR. Хотя должна была затронуть только реализацию
нагрузки с fault simulation.

2. Использование KEDR'ом разных механизмов перехвата вызовов функций, хотя бы на уровне конфигурации пакета
(когда при конфигурации выбирается один механизм перехвата).
Примеры таких механизмов:
а)подмена аргументов инструкций call и jump в бинарном коде загруженного модуля до начала его исполнения(используется сейчас),
б)подмена имен импортируемых функций в объектном файле модуля(применяется в тестовом наборе Novell),
в)тоже самое, что а), но для уже исполняемого модуля, с использованием kprobes(т.н. hot patching)

Зачем:
Каждый из таких механизмов имеет свою область применимости, надежности и удобства по использованию.
Например, текущий механизм(а) легок в runtime-применении, но привязан на архитектуру системы
(реализация для новой архитектуры требует значительных затрат) и не 100% надежен - не все вызовы функций идут через call и jump
с непосредственным операндом.
Механизм (б) не привязан к архитектуре системы(во всяком случае, привязан гораздо меньше, чем (а)) и гарантирует 100%й перехват.
Но требует статического изменения объектного файла тестируемого модуля + усложняется реализация регистрации payload'ов.
Механизм (в) хорош для проверки модулей, которые проблематично выгрузить для применения механизма (а).

3. Развитие шаблонного движка.

Зачем:
Для обогащения возможностей call monitoring, fault simulation, fault simulation scenarios.
Например, call monitoring мог бы выводить информацию как до вызова исходной функции, так и после (krealloc, happens-before replationship).
fault simulation мог бы использовать более широкие возможности по расшариванию сценариев для разных функций.
Для одной функции можно было бы использовать сразу несколько сценариев.
Сейчас такие улучшения наталкиваются на невозможность использования параметров-массивов шаблона нигде, кроме как в глобальной области видимости
и для объектов, отделенных [group].

Для упрощения реализации шаблонов для fault simulation, call monitoring, fault simulation scenarious.