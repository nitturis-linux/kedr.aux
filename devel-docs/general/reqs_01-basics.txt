Требования к базовой функциональности системы анализа драйверов
---------------------------------------------------------------

На данном этапе необходимо иметь возможность анализировать выбранный 
пользователем драйвер (один). 

Возможно, в будущем одним из вариантов использования системы будет такой, 
когда она последовательно применяется (возможно, с разными настройками, 
типами проверок и пр.) к одному или разным драйверам несколько раз. Сейчас 
это поддерживать необязательно, но иметь в виду стоит.

В дальнейшем может понадобиться поддержка одновременного анализа нескольких 
драйверов, но пока это не критично. Тем не менее, если удастся не создавать 
серьёзных затруднений для добавления такой возможности в будущем, это было 
бы неплохо.

Если делать поддержку последовательного анализа нескольких драйверов, то 
нужно обеспечить, чтобы переход к анализу следующего драйвера, по 
возможности, не требовал выполнения длительных операций (перезагрузки ОС в 
частности).
=======================================================================

Нужна возможность отслеживать вызовы драйвером указанных пользователем (или 
заданных по умолчанию) системных функций и сохранять информацию о них для 
последующего анализа в user mode (основной use case) или kernel mode 
(например, в случае, если тестовые воздействия выполняет вышестоящий 
драйвер или driver framework).

По возможности, такое слежение за вызовами не должно сильно влиять на 
работу анализируемого драйвера. В частности, время, необходимое для 
выполнения драйвером той или иной функции не должно сильно отличаться при 
слежении и без него при прочих равных условиях.

[NB] Что значит "сильно" - это проблематично описать здесь. 
=======================================================================

Нужна возможность отслеживать использование ресурсов данным драйвером. Для 
начала стоит отслеживать хотя бы выделение и освобождение памяти, захват и 
освобождение lock'ов разных видов. Затем можно было бы и на другие ресурсы 
обратить внимание.

Стоит иметь возможность сохранять для последующего анализа информацию об 
использовании драйвером указанных ресурсов (хотя бы о передаче указателей 
на них и т.д. в те или иные системные функции).
=======================================================================

Система анализа должна уметь отслеживать вызовы функций данным драйвером, в 
том числе и выполненные в atomic context (interrupt handler, защищённый 
spinlock'ом участок кода и пр.) и сохранять информацию о них для 
последующей обработки.
=======================================================================

Полезна возможность отслеживать исключительные ситуации, возникающие при 
работе драйвера, и сохранять информацию о них для последующего анализа. 

[NB] Информацию эту желательно сохранить так, чтобы она не исчезла при 
обработке данной искл. ситуации системой, т.е. при panic(), например.
=======================================================================

Нужна возможность failure simulation: отказ в выделении ресурсов и вообще, 
failure любой функции, которая может завершиться с ошибкой.

Причём, стоит иметь возможность извне задавать сценарий для этого: все ли 
операции данного типа fail'ить или нет, если не все, то какие и т.п.

[NB] Случайным образом не стоит выбирать, какие операции fail'ить: 
вопроизводимость результатов пострадает.
=======================================================================

Желательно, чтобы система могла автоматически выявлять ошибки след. видов 
при работе анализируемого драйвера (по аналогии с Driver Verifier (DV) для 
Windows):

1. 
Попытка доступа к странице памяти, находящейся сразу перед первой или сразу 
за последней страницей выделенного буфера.

Из описания DV: 
Detection of kernel pool buffer overruns. When the verified driver 
allocates pool memory buffers, Driver Verifier guards them with a 
non-accessible memory page. If the driver tries to use memory past the end 
of the buffer, the driver will crash.

2.
Попытка использования блока памяти, который уже был освобождён или даже ещё 
не был выделен. 

Из описания DV:
Detection of using memory after freeing it. Special pool memory blocks use 
their own memory pages, and do not share memory pages with other 
allocations. When the driver is freeing the block of pool memory, the 
corresponding memory page becomes non-accessible. If the driver attempts to 
use that memory after freeing it, the driver will crash instantly.

3.
Утечки памяти по вине данного драйвера.

Из описания DV:
Detection of memory leaks. Driver Verifier tracks memory allocations made 
by a driver and makes sure the memory is freed before the driver gets 
unloaded.

[NB] Данные для анализа собираются в kernel mode, а вот собственно анализ 
поведения драйвера (обработку этих данных) в kernel mode делать 
необязательно. 

[TODO]
Нужно выяснить, осуществимо ли технически это всё на данном этапе. 
Прототипы соотв. узлов системы тут очень помогут.
=======================================================================

Сбор информации о работе драйвера не должен вызывать нарушений ни в работе  
самого драйвера, ни в работе остальных компонентов ОС. 

Например, если система анализа модифицирует код данного драйвера в памяти и 
перед завершением работы этой системы код драйвера ещё находится в памяти, 
система должна вернуть соотв. участки кода драйвера в исходное состояние.
=======================================================================

Система анализа драйверов должна быть модульной, расширяемой: чтобы новые 
компоненты для неё (или с её использованием) могли и сторонние эксперты 
разрабатывать. Как минимум, не стоит создавать для этого искусственных 
препятствий.

[TODO] 
Более конкретные следствия этого общего требования могут проявиться в 
результате работы с прототипами и пр. Стоит обратить внимание на поддержку 
расширяемости при выполнении этой работы.
=======================================================================
