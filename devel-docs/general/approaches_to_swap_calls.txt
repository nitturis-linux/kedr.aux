Есть, как минимум, 2 подхода к перехвату вызовов из модуля ядра.
=======================================================================

1. 
Ещё до загрузки модуля его таблицу символов изменяют (в user mode): меняют 
имена вызываемых им функций на имена соотв. replacement-функций, 
экспортируемых другим модулем, тем, который и будет выполнять сбор 
информации. 

После этого, при загрузке анализируемого модуля он автоматически 
"слинкуется" уже так, чтобы использовать replacement-функции.

При этом очень желательно не менять длины имён в таблице символов.

Такой подход используется в некоторых тестах для драйверов из Novell Yes 
Certified Program (тесты, правда, после 2007 почти не развиваются).

Обычно там просто первая буква имени функции меняется на заглавную.
=======================================================================

2.
После загрузки модуля подменяются адреса вызовов непосредственно для 
инструкций 'call' и т.п. в памяти. Адрес каждой заданной функции меняется 
на адрес соотв. replacement-функции из модуля, который и будет выполнять 
сбор информации.

Такой подход предполагается использовать у нас в KEDR.
=======================================================================

Достоинства и недостатки указанных выше подходов.

Если коротко, [1] проще в реализации и отладке (хотя и не сильно), но [2] 
предоставляет больше возможностей для построения систем анализа на его 
основе.

[1] (Patching before load, "cold patching")

Достоинства:

+ Несколько проще реализовать по сравнению с [2]. 
В пользовательском режиме к услугам разработчика масса удобных средств: 
libc, libelf и пр. Плюс, не надо заботиться о синхронизации доступа к 
данным и т.д.

+ Проще задавать, вызовы каких именно функций нужно подменять 
(инструментировать): список соответствий {функция; replacement-функция} 
можно просто читать, например, из обычного файла. В случае [2] с этим м.б. 
сложнее, т.к. эту информацию нужно как-то передать из пользовательского 
режима в режим ядра.

+ Проще отлаживать систему подмены вызовов, т.к. это тоже делается в 
пользовательском режиме в данном случае.

Недостатки:

- Отсутствие гибкости в выборе имён replacement-функций: длину имени нужно 
сохранять, иначе обработка анализируемого модуля сильно усложнится. Плюс, 
есть вероятность (хоть и небольшая), что выбранное имя для 
replacement-функции уже для какой-то другой функции из другого модуля 
используется. 

- Сложно реализовать изменение replacement-функции в runtime. Если вместо 
вызовов kfree() в модуле - вызовы Kfree, то без выгрузки модуля заменить 
их, скажем, на KFreE() не удастся. А такое может потребоваться, например, 
для подключения к уже работающему модулю и организации fault simulation для 
него. Не удастся и вернуть kfree() обратно (это нужно, например, если 
модуль, осуществляющий сбор данных, выгружается раньше анализируемого 
модуля). 

[2] (Patching after load, "hot patching")

Достоинства:

- Имя replacement-функции при самом инструментировании не нужно вообще, 
нужен только её адрес в памяти. Replacement-функцию даже необязательно 
экспортировать из соотв. модуля.

- Есть возможность re-patch on-the-fly: заменить один набор 
replacement-функций другим для анализируемого модуля, не выгружая 
последний. Это даёт возможность подключаться и к уже загруженным модулям - 
для слежения за вызовами, fault simulation и пр. Можно и вернуть вызовы 
функций в анализируемом модуле в исходное состояние - и всё это в runtime.

Недостатки:

- Несколько сложнее в реализации, чем [1]: как минимум, на x86/x86_64 нужен 
декодер машинных инструкций для поиска нужных вызовов. К счастью, такой 
декодер в ядре есть (см. реализацию kernel probes для x86 в ядре от 2.6.33 
и новее). С учётом этого - сложности реализации [1] и [2] сопоставимы.

- Т.к. инструментирование идёт в режиме ядра, нужна система передачи в 
соотв. модуль ядра списка функций и replacement-функций из 
пользовательского режима. Не стоит в режиме ядра пытаться работать с 
файлами, как в пользовательском режиме. В случае [1] этих сложностей нет. 
Тем не менее, сложности для [2] преодолимы.

- Сложнее отладка системы инструментирования, т.к. эта система работает в 
режиме ядра.
=======================================================================
