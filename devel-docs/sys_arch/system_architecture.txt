Архитектура системы KEDR
------------------------

Общая схема системы - в файле system_architecture.odg. 

[NB] Это именно функциональная схема, т.е. показывающая, что делают 
основные компоненты системы. Как именно будут оформлены конкретные 
компоненты - вопрос реализации.

На схеме блоки зелёного цвета соотв. компонентам системы. Широкие синие 
стрелки - основные потоки данных. Зелёные стрелки - передача управления. 
Остальные стрелки - связи других видов.
=======================================================================

Система работает след. образом. 

1. 
Система KEDR загружается до загрузки драйвера, который ей предстоит 
анализировать (kernel module under test, KMUT).

2.
Loading Detector встраивается в системные средства для загрузки модулей 
ядра ("Kernel Module Loading Facilities"). Его основная задача: когда ОС 
будет загружать KMUT, перехватить управление после окончания загрузки, но 
перед вызовом init-функции KMUT. Перехватить управление надо именно в той 
kernel thread, которая будет выполнять init-функцию KMUT.

[NB] Loading Detector должен проверить, что загружается именно KMUT, и 
ничего не делать, если это какой-то другой модуль загружается.

Выполнив перехват, Loading Detector передаёт управление блоку Call 
Instrumentator. 

3.
Call Instrumentator делает следующее:

- определяет адреса (в памяти) секций KMUT, содержащих исполняемый код;

- в каждой секции ищет вызовы функций, которые нужно будет отслеживать, и 
нужным образом инструментирует эти вызовы (в простейшем случае, заменяет 
адрес вызываемой функции на адрес соотв. replacement-функции).

Когда это выполнено, управление передаётся init-функции KMUT. Теперь при 
работе KMUT при каждом проинструментированном вызове будет вызвана соотв. 
replacement-функция, принадлежащая какому-л. из компонентов-мониторов, 
например, Call Monitor, Base Checker или Fault Simulator.

4. 
Тестовые воздействия на KMUT производятся приложениями пользовательского 
режима. В дальнейшем можно будет отработать и случаи, когда воздействия 
производятся другими kernel модулями, например, из соотв. device framework.

5.
5.1. Replacement-функции из Call Monitor сохраняют для дальнейшего анализа 
информацию о вызове соотв. целевой функции, о её параметрах и возвращаемом 
значении. Целевая функция при этом вызывается, как обычно.

5.2. Replacement-функции из Base Checker позволяют проверить некоторые 
базовые требования к KMUT. Например, при выделении памяти в KMUT можно 
окружить буфер памяти страницами, обращение к которым вызовет 
исключительную ситуацию и таким образом отловить хотя бы некоторые виды 
buffer overflow.

5.3. Replacement-функции из Fault Simulator позволяют симулировать ошибку 
выполнения соотв. целевой функции (например, возвращение NULL функцией 
__kmalloc()). Таким образом можно приверить, корректно ли KMUT реагирует на 
подобные ситуации.

6.
Данные, собранные replacement-функциями, в конечном счёте попадают в Data 
Collector (что-то на основе DebugFS?). Какой-то сложной обработки этих 
данных в режиме ядра не стоит проводить.

7.
Управление системой производится через специальный Control Interface. Это 
может быть, например, спец. файл-устройство, созданный kernel модулями 
системы KEDR, это может быть и что-то в SysFS и т.п.

Нужно иметь возможность передать системе через Control Interface, какие 
модули ядра ей анализировать, какие настройки использовать, какие сценарии 
fault simulation применять и т.д.

8.
В пользовательском режиме работают компоненты системы, предоставляющие 
приложениям более удобные средства по получению и предварительному анализу 
данных, собранных системой, и по управлению системой (Kernel Module 
Analysis API + Tools).

Приложения обращаются к этим компонентам и, например, получают от них 
информацию о том, какие вызовы, когда и с какими параметрами делал KMUT и 
т.д.

9.
Система выгружается после выгрузки KMUT.
=======================================================================

[TODO]
Перед (!!!) планированием разработки системы стоит подготовить след. 
прототипы:

- прототипы блоков, описанных в пп.1-9 выше, - для анализа технической 
осуществимости и выявления основных проблем (в п.5.2 пару разных типов
 ошибок стоит попробовать для начала);

- прототип системы в целом - для отработки интеграции её компонентов друг с 
другом;

- прототип процедуры установки системы.
