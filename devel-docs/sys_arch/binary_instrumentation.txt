Заметки по инструментированию бинарных файлов модулей с точки зрения
использования системой KEDR
-----------------------------------

Здесь собраны некоторые идеи, которые могут быть, а могут и не быть 
реализованы в системе KEDR в плане инструментирования бинарных файлов
вместо инструментирования уже загруженного в память кода.

=======================================================================

1. Преимущества бинарного инструментирования

1.1. Платформонезависимость
Инструментирование уже загруженного кода невозможно без разбора этого кода
по инструкциям, что неизбежно зависит от архитектуры. Для поддержки каждой
новой архитектуры необходимо написать(или модифицировать существующий в
user-space) парсер инструкций для этой архитектуры, что является сложным
делом.

Инструментирование бинарного файла, используя свойства ELF-формата, позволяет
полностью абстрагироваться от архитектуры.

1.2. Полнота перехвата
Хотя до сих пор в это не упирались, инструментирование уже загруженного кода
не может выполнятся со 100% перехватом всех вызовов исследуемых функций.
Косвенный вызов исследуемой функции практически невозможно надежно определить.

Инструментирование бинарного файла использует relocations, которые указывают
все использования той или иной функции. 100% перехват.

1.3. Определение модуля, вызвавшего функцию
При реализации платформы KEDR для одновременного слежения за несколькими
модулями встает вопрос определения, из какого модуля был сделан тот или иной
вызов функции. Реализация такой возможности при инструментировании уже
загруженного кода модуля возможна, но требует существенной доработки KEDR
(перенос шаблонного кода для применения к каждому наблюдаемому модулю). При
бинарном инструментировании это сделать проще.

1.4. Автоматическая загрузка KEDR при загрузке наблюдаемого модуля за счет
зависимостей между модулями.

При наблюдении за модулем, который загружается при загрузке ОС, KEDR должен загружаться еще раньше. Вручную это сделать невозможно, поэтому необходимо
каким-то способ это реализовать автоматически.

При модификации бинарного файла можно реализовать его зависимость(косвенную) от KEDR за счет импортируемых функций. При такой зависимости KEDR будет загружатся
автоматически при загрузке модифицированного модуля.

2. Принципы использования бинарного инструментирования в KEDR

2.1. Payload'ы не зависят от способа инструментирования
Payload модуль, написанный для использования при инструментировании кода
загруженного в память, должен подходить и для использования при
инструментировании бинарного кода. Изменение кода и перекомпиляция не должны
требоваться.

2.2. Одновременное слежение за несколькими модулями
Очень полезная "фича", должна быть реализована при бинарном инструментировании.

3. Компоненты бинарного инструментирования

3.1. KEDR CORE
Ядро платформы. Управляет payload'ами(регистрация/дерегистрация, фиксирование модулей с payload'ами на время использования,...) и предоставляет интерфейсы для использования payload'ов.

3.2. Payload(s)
См. 2.1

3.3. Template module
Модуль, единственная цель которого - использование при бинарном
инструментировании модуля для наблюдения.
Содержит шаблоны кода, которые будут перенесены в модуль при инструментировании.
Сам по себе не предназначен для загрузки.
Код модуля-шаблона генерируется на основе информации о функциях, перехват
которых требуется для работы некоторого набора payload'ов.



4. Идеи и соображения на тему создания шаблонного модуля и его использования
при инструментировании

4.1
Шаблонный модуль должен содержать шаблоны intermediate функций для всех "интересных" функций (вызов каждой "интересной" функции будет заменен на вызов
соответствующей intermediate функции).
Шаблонный модуль должен содержать шаблоны для "init" и "exit" функций.

4.2
Intermediate функции должны включать всю логику перехвата - получение от
KEDR CORE списка pre-, posthandlers и replacements, формирование структуры,
содержащей информацию о конкретном вызове(return address, caller module),
вызов pre-, post handlers и replacement/original функций в определенном порядке.
(Примерно то же самое, что и intermediate функции, генерируемые сейчас в KEDR
для functions support).


4.3
В инструментированном модуле инстанциируются шаблоны только тех intermediate
функций, соответствующие функции для которых используются в модуле.
Такое выборочное инстанциирование позволяет не вводить лишние зависимости в
инструментированный модуль.
(Например, какой-то payload может захотеть перехватывать функцию foo_bar,
которая экспортируется модулем foo. В то время как инструментированный модуль
может не использовать функцию foo_bar и вообще не зависеть от модуля foo. Если
при инструментировании инстанциировать шаблон для intermediate функции для
foo_bar, то эта инстанциация будет зависеть от самой функции foo_bar(см.4.2). А
следовательно, весь инструментированный модуль будет зависеть от этой функции и
от модуля foo, что нежелательно.)

4.4
init функция должна уведомлять KEDR о загрузке наблюдаемого модуля.

Кроме того, в init функции должно проверяться, что наблюдаемый модуль был инструментирован в соответствии с набором payload'ов, используемым KEDR'ом в
данный момент. Необходимое и достаточное условие соответствия набора payload'ов и инструментирования:
Множество импортируемых наблюдаемым модулем функций, но не перехватываемых им, не пересекает множество функций, перехват которых требуется хотя бы одним payload'ом, используемым в данный момент.

init функция может также запрашивать у KEDR'а информацию о перехвате конкретных
функций и заполнять структуры, которые могут затем использоваться в intermediate
функциях(см. 4.2).

В конце init функция инструментированного модуля должна вызвать init функцию исходного модуля.

4.5
exit функция инструментированного модуля должна вначале вызвать exit функцию исходного модуля, а затем уведомить KEDR о выгрузке наблюдаемого модуля.

4.5
Код шаблонного модуля должен генерироваться по data-файлам, используемым
payload модулями для генерации intermediate функций для functions_support
(functions.data).
Примерная последовательность:
1) набор functions.data файлов
2) склейка всех входных functions.data файлов
3) удаление дубликатов функций
4) генерация шаблонного модуля из получившегося файла по шаблонам.

4.6
Генерация шаблонного модуля и его компиляция должна производиться одновременно с
сборкой и компиляцией соответствующих payload модулей.

При использовании payload модулей, разработанными "третьими лицами", необходимо иметь functions.data файлы для этих модулей (при этом код и бинарник payload'ов
не требуются).

4.7
Список функций, которые необходимо подменить, должен содержатся в отдельной
секции шаблонного модуля. Например, в виде массива структур
{
	void* orig;
	void* intermediate;
}
Имена перехватываемых функций и имена и код соответствующих intermediate функций извлекается из таблицы символов и relocations, используемых для этого
массива(см. прототип snippets/instrument_module_binary_advanced).

Такая инкапсуляция списка перехватываемых функций в шаблонный модуль позволяет
использовать этот шаблонный модуль как содержащий ВСЮ информацию, необходимую
для инструментирования.

4.8
Инструментирование выполняется следующим вызовом:

./instrument_target <target_module> <template_module> [<output_module>]

target_module - модуль для инструментирования
template_module - шаблонный модуль для некоторого набора payload'ов
output_module - модуль-результат инструментирования, если исходный модуль хочется оставить неизмененным(возможна также схема backup'ов)

Инструментирование может выполнятся на любой машине, на которой установлен libelf (elfutils or other package). При кросскомпиляции инструментирование
может производится как на сборочной машине, так и на хосте или на любой другой
машине. Единственное условие - template_module должен быть скомпилирован под архитектуру хоста.

