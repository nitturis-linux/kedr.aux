Список того, чего еще нет, но можно реализовать.

1. Функция 'id'.

Функция раскрывается в порядковый номер итерации параметров для
вычисления шаблона.

Полезно для назначения уникальных идентификаторов функций, переменных
и т.д., которые генерируются по шаблону используя 'join'.
Иначе приходится вводить дополнительный параметр, содержащий уникальный
идентификатор.

<$with function$>void func<$.code: id$>(void)
{
<$code: indent "    "$>
}
<$endwith: join "\n"$>

с параметрами

<root>:
    function:
      - code: "%code1%"
    function:
      - code: "%code2%"

Раскрывается в

void func1(void)
{
    %code1%
}
void func2(void)
{
    %code2%
}


Если ни один из параметров, необходимый для вычисление аргумента 'id',
не итерируется текущим 'join'ом, то берется номер итерации внешнего
'join'. Это полезно при вложенности итераций.

Также может быть введена функция 'id0', которая также возвращает номер
итерации, но начиная с нуля, а не с единицы. Такая функция может быть
полезна для адресации элементов массива, сгенерированного по шаблону.

2. Игнорирование перевода строки, если он следует сразу за директивой.

Полезно для удобочитаемости шаблона.

<$if block1$>
<$block1$>
<$endif$>
<$if block2$>
<$block2$>
<$endif$>

С параметрами 

<root>:
  - block1: "%block1%"
  - block2: "%block2%"

Раскроется в

%block1%
%block2%

Без этой особенности, шаблон пришлось бы (и приходится) писать так:

<$if block1$><$block1$>
<$endif$><$if block2$><$block2$>
<$endif$>

3. Функция join_unique

Тоже, что и 'join', но не пишет строковое представление аргумента, если
точно такое же значение было написано в предыдущей итерации.

"a" "b" "b" "a" "b" "c" "b" "b" : join(=) =>
"a=b=b=a=b=c=b=b"

"a" "b" "b" "a" "b" "c" "b" "b" : join_unique(=) =>
"a=b=c"

Нарушает независимость генерации по шаблону от значений параметров
(без этой функции генератор отличал только пустые значения, что
является минимумом для условной генерации).

Но реализуется несложно.

4. Функция 'indent' не делает отступа в первой строке аргумента.

Из шаблона

void f(void)
{
    <$code: indent "    "$>
}

лучше видно конечное представление кода, чем из

void f(void)
{
<$code: indent "    "$>
}

Или ввести функцию 'indented', которая автоматически определяет отступ
начала текущего шаблона, и добавляет такой же отступ для всех остальных
строк шаблона:

void f(void)
{
    <$code: indented$>
}

Но в этом случае получается зависимость шаблона от предыдущих, и это надо
точнее формализовать.