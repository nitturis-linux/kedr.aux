Прототип шаблонного движка, поддерживающего агрегаты параметров.

Краткое описание.


            Параметры.

[
  По сравнению с mist_engine:
    - появляется иерархия параметров.
    - ссылка на параметр оформляется в виде 'TopParamName.Subname1.Subname2'
    - если ссылка не является однозначной, множество ее значений НЕЛЬЗЯ
      считать простым массивом. Хотя некоторое сходство имеется.
]

Параметры организуются в "кусты", представляемые классом Mist::ParamSet.

Каждый куст имеет строковое значение и может иметь подкусты, каждый из
которых организован по тем же принципам.
Каждый подкуст имеет имя, по которому он идентифицируется в кусте, его
содержащем.
Все подкусты с одним именем упорядочены друг с другом.

Таким образом получается иерархия параметров, корень этой иерархии - куст
у которого нет родительского.

Пример:

<root>:
  - param:
    - subparam("value1")
    - subparam("value2")
  - param:
    - subparam("value3")

  - param1("value4")
  
  - param2
    - subparam2("value5")

Здесь <root> - корневой куст, param - два(упорядоченных) подкуста с
именем "param".
В первом подкусте есть два(также упорядоченных) подкуста с именем
"subparam", которые обладают только значениями "value1" и "value2"
соответственно.
Во втором подкусте только один подкуст "subparam", который обладает
значением "value3".
Также, у корневого куста есть подкуст с именем "param1",
который обладает значением "value4", и подкуст с именем "param2", у
которого есть подкуст с именем "subparam2", который обладает значением
"value5".

Порядка между кустами "param1" и "param2" нет, как и порядка между этими
кустами и любым из кустов "param".


На самом деле, значения есть у всех кустов, в том числе у промежуточных
и у корневого, но обычно они не используются, поэтому не показаны на
схеме(см. далее).


Все кусты можно разделить на два типа: листовые и нет.

У листовых кустов нет подкустов, но их значение обычно используется.
Такие кусты можно считать истинными параметрами - у них есть имя и
значение.

У нелистовых кустов значение обычно не используется, а интересен состав
подкустов. Такие кусты можно называть промежуточными параметрами -
у них есть имя. Или просто параметрами.

NOTE: корневой куст не относится ни к тем, ни к другим, ибо у него нет
имени.

Используется следующий формат ссылки на параметры:

name1.name2

Например, в приведенном выше примере

param1 == "value4"
param2.subparam2 == "value5"

Имя

param.subparam

ссылается не на конкретное значение, а на множество значений:

param.subparam -> {"value1", "value2", "value3"}

NOTE: В отличие от движка mist_engine, это множество нельзя рассматривать
как простой массив, хотя оно обладает порядком.


            Организация шаблонов в библиотеке.
[
    По сравнению с mist_engine:
      - теже шаблоны и их группы
      - специфика библиотеки: группа не конструируется пользователем
       из единичных шаблонов. Вместо этого, пользователь реализует
       в абстрактном классе TemplateCollection абстрактный метод 
       findTemplate(templateName), который по имени шаблона возвращает
       сам этот шаблон, или сообщает, что шаблона нет.
       Причем шаблон может инстанциироваться в момент вызова функции,
       а результат можно не сохранять.
]

Шаблон отвечает за генерацию некоторого строкового представления на
основе параметров.
Сам шаблон, в свою очередь, кодируется в виде некоторого строкового
представления.

Точнее, так как шаблон может ссылаться на другой шаблон(например,
кодирующего часто используемый кусок исходного шаблона), за генерацию
строкового представления отвечает не один шаблон, а группа.

Соответствие с классами библиотеки:

Mist::Template - шаблон, конструируется из строкого представления

Mist::TemplateCollection - абстрактный способ организации шаблонов в
группу, задает соответствие между именами шаблонов и их содержанием.

Mist::TemplateGroup - группа шаблонов, конструируется на основе
экземпляра наследника Mist::TemplateCollection и имени основного шаблона.


            Формат шаблона.
[
    По сравнению с mist_engine:
      - осталось: <$... $>: директивы отделяются от остального текста,
                  <$name$>: ссылка на шаблон/параметр,
                  директивы 'if' и 'join'(по смыслу)
      - изменено: в директиве 'join' тест задается в кавычках, а не
        скобках:
            <$name: join ","$>.
        Причина - в кавычках escape-последовательности выглядят более
        привычно, чем в скобках. Сам символ кавычки может escape-ится
        обычным способом: "\"".
      - изменено: concat(name) в 'if' директиве заменено на join:
          <$if name: join$>.
        Причина: 'join' директива описывает ровно то же, что описывал
        'concat'. Меньше конструкций - проще синтаксис.
      - добавлено: директива 'with':
          <$with name$>internalTemplate<$endwith$>
        internalTemplate - обычный шаблон, join в котором объединяет не
        все возможные значения параметра, а только внутри одного
        экземпляра параметра 'name'. Иными словами, результат join -
        многозначен, с той же "степенью" многозначности, что и параметр
        'name'.
        Наиболее близкая аналогия:
          <$with group$>block<endwith>
        т.е. внутри "скобок" 'with' можно писать те шаблоны, которые
        ранее назывались block и организовывали отдельную группу шаблонов
        со своим поднабором параметров.
      - добавлено: относительные имена
          <$with name1$>...<$.name2$>...<$endwith$>
        Здесь ".name2" ссылается на параметр "name1.name2".
        Значительно сокращает длину используемых имен в часто
        используемых сценариях, а также позволяет переиспользовать
        шаблоны при изменении точки начала иерархии параметров, к
        которой эти шаблоны применяются.
]

    Обычный текст и директивы.

Текст попадает в результирующее строковое представление как есть,
вне зависимости от значений параметров.

Директивы ограничиваются сочетаниями <$ и $>. Внутри директив действует
специальный синтаксис, который обычно меняет поток генерации
представления и/или вставляет значения параметров в это представление.

Будем говорить "конструкция имеет значение/результат" если действие
какой-либо конструкции заключается только в записи соответствующего
строкового значенияв результирующее строковое представление .

    Комментарии
Последовательность '<$!' начинает комментарий, после этого первое
сочетание'$>' его заканчивает:

template_text<$! This is a comment$>next_template_text

    Ссылка на значение параметра.

Директива

  <$name$>

имеет значение совпадающее с значением параметра с именем "name".

Имя параметра может быть сложным, то есть ссылаться не на параметр
верхнего уровня, а на его подпараметр, или подпараметр подпараметра,
и т.д.

    Многозначная ссылка на значение параметра

Если любая из компонент параметра представлена несколькими экземплярами,
то такая ссылка на значение параметра называется многозначной.

В обычных условиях использование такой ссылки запрещено.

Многозначные ссылки предназначены для использования внутри конструкций,
которые при генерации результирующего строкового представления обходятся
несколько раз.

В таком случае, во время каждого обхода используется какое-то одно
значение параметра(см. описание директивы 'join').

    Ссылка на значение отсутствующего параметра.

Если же какая-либо из компонент параметра отсутствует, то значением
ссылки на такой параметр считается пустая строка ("").

Однако, если при этом какая-либо из компонент параметра представлена
несколькими экземплярами, то каждому такому экземпляру соответствует
свое пустое значение, то есть ссылка становится многозначной.
Например, если дерево параметров следующее:

<root>:
  - param:
    - subparam1("value1")
  - param:
    - subparam2("value2")

то ссылка 

<$param.subparam3$>

многозначная, множество ее значений 

{"", ""}

Даже если параметр представлен один экземпляром, множество значений
ссылки на него может быть многозначным, если какой-либо из его компонентов
представлен несколькими экземплярами.
В предыдущем примере следующие ссылки многозначны:

<$param.subparam1$> -> {"value1", ""}
<$param.subparam2$> -> {"", "value2"}


   Правило вычисления значений ссылок на параметры

Следующее правило может быть использовано для определения, какие значения
может принимать ссылка на параметр:

!  К любому параметру можно добавить пустой подпараметр с именем, которого
!  в исходном параметре нет. При этом интерпретация набора параметров не
!  меняется.
!  Под пустым подпараметром подразумевается параметр со значением ""
!  (пустая строка), у которого нет подпараметров.


Используя это правило несколько раз, дерево параметров из раздела
"Ссылка на значение отсутствующего параметра" можно изменить так:


<root>:
  - param:
    - subparam1("value1")
    - subparam2("")
    - subparam3("")
  - param:
    - subparam1("")
    - subparam2("value2")
    - subparam3("")

В таком варианте все экземпляры параметров становятся явными, и
многозначность ссылок

<$param.subparam1$>, <$param.subparam2$>, <$param.subparam3$>

становится очевидной.

Более сложный пример:

<root>:
  - param:
    - subparam1:
      - internal("value1")
  - param:
    - subparam2("value2")
  - param:
    - subparam1:
      - internal_other("value3")

В данном дереве

<$param.subparam1.internal$> -> {"value1", "", ""}

Такое множество значений можно увидеть в дереве, эквивалентному данному
по интерпретации:

<root>:
  - param:
    - subparam1:
      - internal("value1")
  - param:
    - subparam1:
      - internal("")
    - subparam2("value2"
  - param:
    - subparam1:
      - internal("")
      - internal_other("value3")
      

    УТОЧНЕНИЕ ДЛЯ ДАЛЬНЕЙШЕГО ИЗЛОЖЕНИЯ

!!! Говоря про какой-либо параметр и его значение, мы считаем что дерево
!!! параметров с использованием правила "вычисления значений ссылок на
!!! параметры" дополнено так, что все значения параметра в этом дереве
!!! отражены явно.

В таком случае нет смысла говорить про отсутствующие параметры как в целом,
так и внутри определенного параметра(более верхнего уровня).


    Ссылка на шаблон.
    
Директива <$name$> может также быть ссылкой на шаблон с именем "name".
В этом случае эта директива интерпретируется как если бы все содержимое
шаблона было написано вместо нее.

Следующий способ используется для определения, является директива

<$name$> ссылкой на параметр или шаблон:

Если существует шаблон с именем "name", то директива является ссылкой на
шаблон, иначе директива является ссылкой на параметр.

Имя шаблона не может содержать символ ".", поэтому директива, например,

<$param.subparam$>

может быть только ссылкой на параметр.


    Директива объединения значений параметра('join')

Значением директивы

<$name: join$>

является объединение всех значений параметра "name".

Директива эквивалентна обычной ссылке на параметр, если эта ссылка
однозначная.

При объединении учитывается порядок параметров(см. раздел "Параметры").
При этом порядок параметров верхнего уровня имеет приоритет выше, чем
порядок параметров нижнего уровня.

С параметрами

<root>:
  - param:
    - subparam1:
      - internal("value1")
  - param:
    - subparam1:
      - internal("value2")
      - internal("value3")
  - param:
      - internal("value4")

результат директивы 

<$param.subparam1.internal: join$>

будет

"value1value2value3value4"

Можно также указать текст, который будет вставляться между
последовательными значениями параметра:

<$name: join "text"$>

С вышеприведенными параметрами результат директивы

<$param.subparam1.internal: join ", "$>

будет

"value1, value2, value3, value4"

Указывая текст для 'join' необходимо учитывать что этим текстом будут
отделяться также и пустые значения параметра.

Следующие escape-последовательности можно использовать внутри "":
"\n", "\t", "\"".


    Директива объединения значений шаблона('join')

Директива

<$name: join$>

может работать не только с параметром, но и шаблоном, если шаблон с
таким именем есть.

В таком случае, директива последовательно пишет значение  шаблона
с различными наборами значений параметров. Итерация значений параметров
для шаблона подчиняется следующим правилам:

    1. (Множество параметров для итерации) В итерации используются
       только те параметры, ссылки на значения которых есть в шаблоне.
       
       NOTE: Это важное условие. Изменение множества параметров может
       повлечь за собой изменение результата итерирования.
    
    2. (Первая итерация) Для каждого параметра выбирается первое его
       значение в списке значений. С таким набором значений проходит
       первая итерация.

    3. (Следующая итерация) Для каждого параметра при переходе к
       следующей итерации выбирается следующее значение параметра по
       порядку. Если следующего значения нет, то значение не меняется. 

    4. (Корректировка итерации) Если два параметра имеют общие
       компоненты (параметры верхнего уровня, к которым принадлежат оба
       параметра), то для каждой итерации значения обоих параметров
       берутся из иерархии, относящейся к одному общему предку параметров.
       
       Если переход к следующему значению двух параметров нарушает это
       правило по какому-то общему предку, то для
       тех параметров, чье следующее значение изменяет этого предка,
       значение не меняется. (Если следующее значение параметра не меняет
       предка, то он итерируется как обычно).

       NOTE: Первая итерация всегда удовлетворяет этому правилу.

    5. (Условие завершения итераций) Перебор значений заканчивается на
       той итерации, когда для каждого параметра выбрано последнее
       значение из возможных.

Демонстрация третьего принципа:

<root>:
  - name("name1")
  - name("name2")
  - value("value1")
  - value("value2")
  
paramAssignment: "<$name$> = <$value$>"

В таких условиях, директива 

<$paramAssignment: join ", "$>

раскрывается в 

"name1 = value1, name2 = value2"

Тот же результат, но с структурным подходом к организации параметров:

<root>:
  - param:
    - name("name1")
    - value("value1")
  - param:
    - name("name2")
    - value("value2")
  
paramAssignment: "<$param.name$> = <$param.value$>"


Демонстрация четвертого принципа:

<root>:
  - param:
    - name("first")
    - name("others")
    - value("value1")
    - value("value2")
    - value("value3")
  - param:
    - name("first2")
    - name("others2")
    - value("value4")

paramAssignment: "<$param.name$> = <$param.value$>"

В таких условиях, директива 

<$paramAssignment: join ", "$>

раскрывается в 

"first = value1, others = value2, others = value3, first2 = value4, others2 = value4"


    Директива условной инстанциации('if')

Конструкция

<$if name$>templateInternal<$endif$>

раскрывается в templateInternal, если <$name$> не пустая строка. Иначе
эта конструкция раскрывается в пустую строку.

Если же <$name$> или templateInternal - многозначны, то при итерациях
внутри 'join' используются теже значения параметров, что при итерации
значений параметров для шаблона

<$name$>templateInternal

(как если бы 'if' был опущен)

Конструкция

<$if name$>templateInternal1<$else$>templateInternal2<$endif$>

раскрывается в templateInternal1, если <$name$> не пустая строка. Иначе
эта конструкция раскрывается в templateInternal2.

Директива

    <$if name: join$>

эквивалентна директиве

    <$if template$>

где "template" - уникальное имя шаблона с содержанием

    <$name: join$>


    Директива установки контекста('with')

Конструкция

    <with name$>templateInternal<$endwith$>

где "name" - имя параметра(только параметра, не шаблона!) эквивалентна

    templateInternal

с следующим отличием:

Если в процессе инстанциации templateInternal выполняется итерирование
по значениям параметров, то итерируются только подпараметры параметра
"name", а остальные параметры (в том числе сам "name") берутся извне
итерации и остаются неизменными на время этой итерации.


Пример:

<root>:
  - prefix("A_")
  - param:
    - name("name1")
    - value("value1")
    - name("name2")
    - value("value2")
  - prefix("B_")
  - param:
    - name("name3")
    - value("value3")
  
paramAssignment: "<$prefix$><$param.name$> = <$param.value$>"

Конструкция

<$prefixedAssignment: join "; "$>

где "prefixedAssignment" - шаблон с содежранием

<$with param$><$paramAssignment: join ", "$><$endwith$>

интерпретируется как

"A_name1 = value1, A_name2 = value2; B_name3 = value3"


Для сравнения, если убрать обертку 'with' из шаблона "prefixedAssignment":

<$paramAssignment: join ", "$>

то результат интерпретации изменится:

"A_name1 = value1, B_name2 = value2, B_name3 = value3"



    Относительные имена параметров

Формат относительных имен параметров:

    .subname

где subname - имя параметра относительно какого-то другого.

Если параметр используется внутри 'with' конструкции, то в качестве
базового параметра выступает параметр, установленный в 'with'
директиве:

<$with name$><$.subname$><$endwith$>

эквивалентно

<$name.subname$>

Вне всех 'with' конструкций имя параметра ".subname" эквивалентно
"subname", за исключением того, что это имя безусловно ссылается на
параметр, а не шаблон.

Относительное имя параметра может использоваться везде, где разрешено
полное имя. В том числе, в самой 'with' директиве.


        Рекурсия

NOTE: Хотя последнее свойство (возможность использовать в директиве
'with' относительные имена параметров) позволяет создавать рекурсивные
шаблоны, использование таких шаблонов в данной реализации не поддерживается.