Рассматривается задача запуска контроллера для target'а, который загружается при загрузке системы.

А. [Упрощенная задача] Автоматический предварительный запуск контроллера со всей нагрузкой при загрузке target'а.
Считается, что загрузка target'а происходит после загрузки системы(в этом упрощение).

А1. Если все модули KEDR'а установлены вместе с другими модулями системы(/lib/modules/`uname -r`/), то надо вызвать

    depmod

для обновления файла с зависимостями модулей, и их алиасов.
Если все модули KEDR'а установлены в директории, отличной от стандартной, вызвать
    depmod -b <root-directory-with-drivers>

(считается, что модули установлены в <root-directory-with-drivers>/lib/modules/`uname -r`/)

А1.1.[вообще, это нужно только для написания скриптов загрузки/выгрузки KEDR]
Далее считаем, что модули KEDR доступны по коротким именам(типа cp_controller).

В случае глобальной установки модулей это выполняется
автоматически, в случае локальной установки необходимо создать файл
    /etc/modprobe.d/kedr.conf
со следующими строчками:

install <module_name> modprobe -d <root-directory-with-drivers> <module_name> $CMDLINE_OPTS
remove <module_name> modprobe -r -d <root-directory-with-drivers> <module_name>

для всех модулей KEDR (<module_name> - короткое имя модуля).

А2. Поиском по всем файлам 
    /etc/modprobe.d/*.conf
ищем строчку, начинающуюся на

install <target_name>

Если такой строчки нет, считаем что она создана в файле, например,
    /etc/modprobe.d/kedr_auto.conf

со следующим содержимым:

install <target_name> modprobe --ignore-install <target_name>

Заменяем найденную(или созданную) строчку с шаблоном

install <target_name> [commands]

на

install <target_name> <script-to-start-controller>; [commands]

Аналогично, ищем строчку с шаблоном

remove <target_name> [commands]

заменяя ее на

remove <target_name> [commands]; <script-to-stop-controller>

Если строчки изначально не было, считаем ее

remove <target_name> modprobe -r --ignore-remove <target_name>

A3. Готово.
Теперь при попытке загрузить модуль <target_name> с помощью

    modprobe <target_name>

(а это основной и предпочтительный способ загрузки модулей),
будет выполнен <script-to-start-controller>, а при выгрузке модуля с помощью

    modprobe -r <target_name>

будет выполнен <script-to-stop-controller>.

Б. Основная задача.

Выполняется также как задача A, только все изменения должны быть отражены не только
в основной файловой системе, но и в образе ядра (initrd.img).

Так как файлы /etc/modprobe.d/*.conf будут читатся из образа ядра, то используемые в них скрипты и модули
должны также находится в образе ядра:
-скрипты должны быть установлены в /bin (/sbin)
-скрипты не должны использовать параметры, недоступные из образа ядра
-модули должны быть установлены в системную директорию

Задача А несложно автоматизируется, и будет автоматизирована в KEDR.
Задача Б несложно автоматизируется только в части задачи А, автоматизация обновления образа ядра пока неясна.
Более того, пока что не ясен даже сам процесс обновления образа ядра, без автоматизации.

update:
Для OpenSUSE 11.2 и Fedora 13 работает такой способ обновления ядра:

В1. Создаем временную директорию <initrd-dir>, куда будем распаковывать образ. Далее все под root.
В2. Распаковываем образ во временную директорию:
    cd <initrd-dir>
    gunzip < <kernel-image-file> | cpio -imd

<kernel-image-file> - /boot/initrd.. , /boot/initram... , или что-то похожее.
В3. Добавляем файлы в распакованный образ(в соответственные директории):
    - etc/modprobe.d/kedr_auto.conf
    - lib/modules/`uname -r`/.../contoller.cp
    - модули нагрузки
    - другие файлы(если будут использоватся на этапе загрузки системы)
В4. Выполняем

    depmod -b <initrd-dir>

В5. Делаем backup образа ядра

    cp <kernel-image-file> <kernel-image-file-backup>

В6. Перезаписываем образ ядра
    cd <initrd-dir>
    find ./ | cpio -oac | gzip > <kernel-image-file>

Дополнения:
1. Так как на этапе загрузки файловая система содержит только распакованный образ ядра,
то capture_trace должен запускатся не на этапе загрузки системы, а где-нить из etc/init.d/
2. Для разрешения tracepoint'ов в образе ядра можно создать дополнительную временную директорию,
в которую и монтировать debugfs перед загрузкой.

На Ubuntu 10.04 и Mandriva 2010 все эти действия тоже проходят, но по непонятным причинам на Ubuntu
получившийся образ не распаковывается, а на Mandriva не выполняется(некорректно выполняется) install для target'а,
из-за чего он не загружается.