Реализация перехвата вызовов операций для различных объектов по аналогии с перехватом вызовом функций в KEDR.

В ядре Linux много различных типов объектов используют операции (т.н. реализация наследования в ООП в ядре),
и типы и предназначение этих операций сильно отличаются.

Поэтому был реализован базовый интерфейс для перехвата вызовов абстрактных операций для абстрактных объектов.
Этот интерфейс может быть использован для реализации перехвата операций конкретного типа для объектов конкретного типа.

Ключевые особенности механизма перехвата операций:

1. Под перехватом операции подразумевается вызов пользовательской функции вместо вызова этой операции(как в KEDR).

NOTE: Ниже под "подменой операций" понимается механизм, за счет которого вызов исходной операции подменяется вызовом пользовательской функции.
Можно считать, что "подмена операций" синоним к "перехват операций".

2. Указание, какая операция должна подменятся и какой пользовательской функцией, производится через регистрацию payload'ов(как в KEDR).

В отличие от payload'ов KEDR'а, в которых указывается, функции с какими адресами должны быть подменены и
чем (адреса replacement функций), то в payload'ах подмены операций указывается две заполненные структуры операций соответствующего типа.
В первой структуре все операции, подлежащие подмене, отмечаются через REPLACEMENT_MASK.
Все остальные поля структуры должны быть заполнены нулями. Это т.н. маска(mask) подмены операций.
Во второй структуре должны быть указаны адреса подменяющих операции.

3. Для получения адреса исходной операции внутри подменяющей операции необходимо использовать функцию типа *_get_orig(),
которой надо указать объект, операция которого была подменена, и саму операцию - либо ее имя, либо ее смещение внутри структуры операций.
Объект берется из аргументов операции(чаще - это первый аргумент операции).

4. Реализация подмены операций выполняется за счет подмены значения поля объекта,
указывающего на структуру с операциями над данным объектом, или за счет подмены адресов самих операций в структуре самого объекта.
В обоих случаях, для инициации перехвата операций надо иметь существующий объект.

Отсюда следует, что процесс подмены операций должен производится отдельно для каждого объекта. Этот процесс подмены должен быть инициирован
перед тем как операции объекта могут вызыватся извне. Чаще всего, это момент создания объекта.

Так как объекты различного типа создаются разными способами (более того, объекты одного типа могут создаватся многими способами),
то базовый интерфейс подмены операций только предоставляет функцию operation_replace(), выполняющую подмену операций для конкретного объекта.
Ответственность за вызов этой функции в нужный момент лежит на реализации подмены операций конкретного типа.
Для этого, обычно, достаточно перехватить (например, с помощью KEDR'а) какую-то глобальную функцию,
и в реализации перехватчика вставить вызов функции подмены операций.
В случае многоуровневой системы объектов (например, VFS) объекты нижних уровней могут создаватся из операций для объектов верхнего уровня.

5. Если объект, операции которого надо перехватывать, создается в глобальной функции, то нужно создать payload (KEDR), в котором подменить
эту функцию создания. При этом в функциях обратного вызова необходимо вызвать соответственно *_target_load_callback и *_target_unload_callback
для механизма, осуществляющего подмену операций в создаваемом объекте.

Такие функции обратного вызова создают т.н. "связь" между механизмом подмены операций конкретного типа и соответствующими глобальными функциями.
Эта связь обеспечивает:
-фиксирование payload'ов для подмены операций в момент загрузки target модуля
-освобождение payload'ов от фиксации в момент выгрузки target модуля
-проверку, что подмены операций для всех объектов были восстановлены при выгрузке target модуля(о восстановлении операций - далее)
-вызов функций обратного вызова для payload'ов зарегистрированных для подмены операций при загрузке/выгрузке target модуля

Одна из важных особенностей такого рода связей - высокая степень их масштабируемости.
Один тип подмены операций можно связать с несколькими функциями создания объектов с этими операциями НЕЗАВИСИМО,
при этом весь механизм подмены будет работать корректно.

6. Аналогично, если объект создается в операции какого-либо другого объекта, то нужно создать payload для подмены этой операции, в котором
подменить эту операцию создания и в функциях обратного вызова вызвать *_target_load_callback и *_target_unload_callback для механизма,
осуществляющего подмену операций для создаваемого объекта.

Т.о. связи между механизмами подмены конкретного типа операций друг с другом и с глобальными функциями могут представлять собой направленный граф.
Этот граф может быть в том числе и циклическим, и даже содержать дугу от вершины к ей же самой.
При этом гарантируется корректная работа механизмов подмены.

Пример такого графа связей между механизмами подмены конкретных типов операций - в fs_operation_replacement.c.

7. Перехват одной операции для различных целей.
Как и в KEDR'е, на payload'ы для перехвата конкретного типа операций накладывается ограничение, что множества операций, которые они перехватывают,
не должны пересекатся. Такое ограничение, однако, сильно мешает принципу независимости связей между механизмами подмены операций - разные связи
не могут использовать одну и ту же операцию.

Поэтому введен особый тип payload'ов, избавленных от такого ограничения - special payloads.
Сам по себе тип таких payload'ов не отличается от обычных. Отличаются только методы его использования.
Регистрация происходит через *_payload_register_special, дерегистрация - через *_payload_unregister_special.
Внутри заменающей операции в таких payload'ах для получения адреса исходной функции надо использовать функцию 
*_get_orig_special(), которая принимает те же параметры, что и *_get_orig() плюс адрес payload'а, в котором зарегистрирована
эта заменяющая операция.

Механизм подмены операций гарантирует, что подменяющие операции из всех special payload будут вызваны. Но для этого
заменяющие операции из special payload'ов должны обязательно вызывать исходную операцию. Для заменяющих операций простых payload'ов
такого ограничения нет.

(Принцип реализации вызова всех заменяющих операций прост - *_get_orig_special() в действительности возвращает не обязательно адрес исходной
операции над объектом, а может вернуть адрес заменяющей операции из другого payload'а. Получается цепочка вызова подменяющих операций.)

Поэтому, для реализации связей между механизмами подмены операций используют не простые payload'ы, а специальные.

8. После того, как использование операций какого-то объекта прекращается (например, объект удаляется), необходимо освободить ресурсы,
затраченные на подмену операций для этого объекта. Как и в случае с подменой операций, базовый интерфейс только предоставляет функцию
operation_replacement_clean(), предназначенную для освобождения ресурсов. Вызов этой функции должна выполнять реализация подмены
операций конкретного типа. Чаще всего, этот вызов можно осуществить из перехватчика функции/операции удаления объекта. Реализация такого перехвата
осуществляется аналогично реализации перехвата операции создания объекта и вызова operation_replace(). (см. пункты 4,5,6).

В некоторых случаях вместо перехвата событий создания/удаления объекта удобнее перехватывать события регистрации/дерегистрации объекта.
При этом считается, что операции над объектом могут вызываться только между этими двумя событиями.
После дерегистрации объект может быть переиспользован в следующей регистрации, и его операции могут использоватся вновь.
Поэтому, для освобождения ресурсов при дерегистрации объекта надо использовать не operation_replacement_clean(), а operation_restore().
Последняя функция, помимо освобождения ресурсов, восстанавливает операции объекта такими, какими они были при регистрации.

9. (технические сложности применения подмены операции)
Бывают случаи, что невозможно перехватить момент создания объекта, и часть операций с объектом перехватить в принципе не удается.
В таких случаях можно заменять операции в тот момент, который можно перехватить.
Пример - создание корневых dentry и inode для super_block'а.

В некоторых случаях, объект сам восстанавливает свои операции на те, которые были до обновления. С точки зрения автора такой реализации
ничего противозаконного не делается - если операции объекта еще не поставлены, то значит они еще не использовались, и их можно спокойно установить.
Если же операции уже были установлены, то происходит просто перезапись того же значения в поле объекта, что также ничего плохого не влечет.

Однако с точки зрения реализации перехвата операций, такое поведение объекта ведет к потере возможности перехвата. Чтобы хоть как-то обходить
такие случаи, в базовом интерфейсе есть функция operation_replacement_update(). Эта функция восстанавливает перехват операций для объекта, если
перехват был потерян. Если же перехват еще не был инициирован для данного объекта, то работа функции аналогична operation_replace().
Вызывать такую функцию стоит после всех функций/операций, которые могут изменить операции объекта.
При этом, однако, часть вызовов операций над данных объектом, может быть потеряна - это те вызовы, которые произошли за то время, пока у объекта
были установлены его исходные операции + некоторый лаг на синхронизацию между процессорами.