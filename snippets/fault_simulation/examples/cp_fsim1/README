Пример, демонстрирующий использование библиотеки Fault Simulation.

cp_fsim1 - Payload module, написанный по основе cp_payload1 из controler_payload. В нем используется две точки для Fault Simulation - для __kmalloc и для kmem_cache_alloc. В обычном состоянии ветвление в этих точках попадает на "нормальную" ситуацию - т.е такой Payload ведет себя также, как и исходный cp_payload1.

Однако при запущенном модуле fault_control в точку для __kmalloc устанавливается индикатор, который всегда возвращает 1 - эмулируется невозможность выделить память.
При выгрузке модуля fault_control индикатор опять возвращается в состояние по умолчанию - эмуляция "нормальной" работы механизма выделения памяти.

Для компиляции примера директорию с этими модулями надо поместить внутрь рабочей директории controler_payload:

-cp_controller
-cp_payload1
-cp_payload2
-cp_payload3
-cp_fsim1
-cp_target

Вначале запускается модуль cp_fsim1(под управлением контроллера), затем запускается  cp_target. По логам видно, что загрузка прошла нормально, __kmalloc выделил память.
Загружаем модуль fault_control. И пробуем записать чего-то в файл /dev/cfake0 - "out of memory"(в логах).
Выгружаем модуль fault_control, повторяем попытку записать - все проходит нормально.

update: Появилась возможность управлять индикаторными функциями из user space, и этот же payload стал примером для демонстрации этой возможности. Поэтому в makefile осталась только сборка самого cp_fsim, без сборки модуля fault_control.
Для сборки fault_control можно раскомментировать строчку
# obj-m := $(MODULE_NAME).o fault_control.o
(и закомментировать следующую).
