Пример для демонстрации поиска вызовов функций в данном модуле ядра в 
runtime. Работает только на x86 и x86_64.
=======================================================================

Анализируется сам модуль 'instr_detect', a также модуль 'vboxguest' (если 
этот модуль в системе есть и есть возможность поиска модулей по имени - см. 
find_module()).

В коде модулей ищутся вызовы функций __kmalloc, kfree, copy_*_user, printk 
- этот набор функций взят просто для примера.

Данные о найденных вызовах выводятся в /var/log/messages (см. сообщения с 
префиксом "[CFake]").

Послед-ть действий:
- make
- insmod instr_detect.ko
- см. /var/log/messages

[NB] Дополнительные пояснения см. в комментариях в коде примера.
=======================================================================

Работа в примере идёт след. образом. 

Используется декодер x86-инструкций (взят из ядра 2.6.33.1 с kernel.org). С 
его помощью делается проход по коду анализируемого модуля. Когда находится 
инструкция call нужного вида, соотв. вызову интересующей нас функции, в лог 
выводится сообщение.

[NB] Декодер скопирован из ядра без изменений (см. каталог arch в примере). 
Пример должен нормально собираться и работать и тогда, когда в самом ядре 
такого декодера нет.

В ядре Linux этот декодер, похоже, используется при реализации kernel 
probes на x86 и x86_64.
=======================================================================

[NB] В качестве "первичного материала" был взят сильно упрощённый вариант 
драйвера scull из LDD Book - это чтобы можно было попробовать анализатор на 
"настоящем" коде драйвера, а не только на функциях-пустышках.
=======================================================================

Помимо всего прочего, Makefile для данного примера показывает, как можно 
модуль собирать из файлов, разбросанных по разным подкаталогам, как делать 
правила для генерации необх. файлов (например, таблиц х86-инструкций в виде 
С-кода из их текстового представления) и т.п.
=======================================================================

О расположении данных и кода модуля в памяти.

Для каждого модуля ядра, загруженного в память, данные и исполняемый код 
находятся в двух областях. Эти области можно условно назвать 'init' и 
'core', следуя обозначениям полей в struct module (см. 
/usr/include/linux/module.h)

В 'init' - то, что в коде модуля было отмечено как __init (как правило, это 
init-функция модуля и данные, которые использует только она). 

В 'core' - всё остальное.

Теоретически, области 'init' может в модуле и не быть.

Секции с исполняемым кодом находятся в самом начале соотв. областей, затем 
идут остальные секции. 

Для каждой из областей 'init' и 'core' в struct module хранится адрес 
начала области, общий размер, размер исполняемого кода.
=======================================================================

Пример instr_detect проверялся на след. системах (в скобках - версии ядра):

1. OpenSUSE 11.2 x86 (2.6.31.x) - OK 

2. SLES 11 x86_64 (2.6.27.x) - OK

3. RHEL 5 (kernel: 2.6.18.x), SLES 10 (2.6.16.x) - не вышло:
декодер собрать невозможно: не находится header <asm/insn.h> 
(./arch/x86/include/asm/insn.h). 

Видимо, KBuild не подхватил заданные мной опции '-I' почему-то.

4. Fedora 12 x86_64 - OK

5. Ubuntu 10.04 beta 1 x86 (2.6.32.x) - OK

6. Debian 5 x86_64 (2.6.26.x) - OK

7. Mandriva Cooker (2010) x86 (2.6.31.12) - OK
=======================================================================
